<!doctype html> 
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <title>R2U Kakao Map</title>

  <style>
    html, body {
      margin:0;
      padding:0;
      height:100%;
      overflow:hidden;
    }
    #map { width:100%; height:100vh; }

    /* ğŸ”µ ëŸ¬ë„ˆ ì•„ì´ì½˜ */
    .runner-wrapper {
      position: absolute;
      transform: translate(-50%, -50%);  /* ì¤‘ì‹¬ì´ ì¢Œí‘œì— ë”± ì˜¤ë„ë¡ */
      /* ğŸš¨ í´ë¦­/í„°ì¹˜ ì´ë²¤íŠ¸ë¥¼ ì§€ë„ì— ì „ë‹¬í•˜ë„ë¡ ì„¤ì • (CSSëŠ” ìœ íš¨í•¨) */
      pointer-events: none; /* ë¹¨ê°„ì¤„ ì‹ ê²½ ì•ˆ ì¨ë„ ë¨ */
    }

    .user-dir-marker-outer {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      background: rgba(33, 150, 243, 0.28);
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      transition: transform 0.18s linear;
      will-change: transform;
    }

    .user-dir-marker-core {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #1E88E5;
      border: 3px solid #FFFF;
      box-shadow: 0 0 5px rgba(0,0,0,0.4);
      position: relative;
    }

    .user-dir-marker-arrow {
      position: absolute;
      top: -14px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 12px solid #1E88E5;
    }

    /* ì½”ìŠ¤ ìœ„ ë°©í–¥ í™”ì‚´í‘œ (ì¶œë°œ/í„´ ì§€ì ìš©) */
    .route-arrow {
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 16px solid #00FA73; /* ê¸°ë³¸: í˜•ê´‘ì´ˆë¡ */
      filter: drop-shadow(0 0 3px rgba(0,0,0,0.8));
    }
  </style>

  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=f3beaea643bdd2136019b366df1190cf&libraries=geometry,geometry"></script>
</head>

<body>
  <div id="map"></div>

  <script>
    /* ========= ì „ì—­ ========= */
    window.r2uOffRouteWarned = false;
    window.r2uBackToRouteWarned = false;

    window.r2uIsOffRoute = false;
    window.r2uLastOffRouteSpoken = false;
    window.r2uLastIdx = 0;

    let map;

    let routeCoords = [];              // Polyline ì¢Œí‘œ
    let routePolylines = [];           // ì„¸ê·¸ë¨¼íŠ¸ë³„ Polyline ì¸ìŠ¤í„´ìŠ¤
    let routeLineBase = null;          // í°ìƒ‰ ë‘êº¼ìš´ ë² ì´ìŠ¤
    let startMarker = null;
    let endMarker = null;

    let runnerOverlay = null;
    let runnerWrapperDiv = null;

    let isNavigationMode = false;
    let defaultMapLevel = 3;

    let routeArrows = [];              // í„´ í™”ì‚´í‘œ
    let routeTurns = [];               // í„´ ì •ë³´ ë°°ì—´

    // â­ ë°±ì—”ë“œì—ì„œ ë°›ì€ ì„¸ê·¸ë¨¼íŠ¸ ì›ë³¸ (ì§€ë‚˜ì˜¨ ê¸¸ ìƒ‰ ê°±ì‹ ìš©)
    let routeSegmentsRaw = [];

    /* ========= ì§€ë„ ì´ˆê¸°í™” ========= */
    function initMap() {
      const container = document.getElementById('map');
      map = new kakao.maps.Map(container, {
        center: new kakao.maps.LatLng(37.4507, 126.6530),
        level: 3
      });
      defaultMapLevel = map.getLevel();
    }
    initMap();

    /* ========= ë°©í–¥ í™”ì‚´í‘œ ========= */
    function createRouteArrows(coords) {
      if (!kakao.maps.geometry || !kakao.maps.geometry.spherical) {
        return;
      }

      if (routeArrows.length) {
        routeArrows.forEach(a => a.setMap(null));
        routeArrows = [];
      }
      if (!coords || coords.length < 2) return;

      if (routeTurns && routeTurns.length) {
        routeTurns.forEach(turn => {
          const tLat = turn.lat;
          const tLng = turn.lng;
          if (typeof tLat !== 'number' || typeof tLng !== 'number') return;

          const pos = new kakao.maps.LatLng(tLat, tLng);

          let nearestIdx = 0;
          let minDist = Infinity;
          for (let i = 0; i < coords.length; i++) {
            const d = kakao.maps.geometry.spherical.computeDistanceBetween(
              pos,
              coords[i]
            );
            if (d < minDist) {
              minDist = d;
              nearestIdx = i;
            }
          }

          const baseIdx = Math.min(nearestIdx, coords.length - 2);
          const segP1 = coords[baseIdx];
          const segP2 = coords[baseIdx + 1];

          const dx = segP2.getLng() - segP1.getLng();
          const dy = segP2.getLat() - segP1.getLat();
          const angleRad = Math.atan2(dy, dx);
          const angleDeg = angleRad * 180 / Math.PI;
          const rotateDeg = angleDeg - 90;

          let color = '#FFFFFF';
          if (turn.type === 'left') {
            color = '#FF7043';
          } else if (turn.type === 'right') {
            color = '#42A5F5';
          } else {
            color = '#FFFFFF';
          }

          const html =
            `<div class="route-arrow" style="
              transform: rotate(${rotateDeg}deg);
              transform-origin: 50% 50%;
              border-bottom-color: ${color};
            "></div>`;

          const overlay = new kakao.maps.CustomOverlay({
            position: pos,
            content: html,
            zIndex: 5
          });
          overlay.setMap(map);
          routeArrows.push(overlay);
        });
      }
    }

    /* ========= ë„¤ë¹„ê²Œì´ì…˜ ëª¨ë“œ on/off ========= */
    window.setNavigationMode = function(isNav) {
      isNavigationMode = !!isNav;

      if (isNavigationMode) {
        if (map && routeCoords.length > 0) {
          const startPos = routeCoords[0];
          map.setLevel(2);
          map.panTo(startPos);
        } else if (map) {
          map.setLevel(2);
        }

        if (routeCoords.length && !routeLineBase) {
          routeLineBase = new kakao.maps.Polyline({
            path: routeCoords,
            strokeWeight: 10,
            strokeColor: '#FFFFFF',
            strokeOpacity: 0.9,
            strokeStyle: 'solid',
            zIndex: 1,
          });
          routeLineBase.setMap(map);
        }

        createRouteArrows(routeCoords);
      } else {
        if (map) {
          map.setLevel(defaultMapLevel);
        }
        hideRunnerOnRoute();
      }
    };

    /** ëª¨ë“  ì„¸ê·¸ë¨¼íŠ¸ í´ë¦¬ë¼ì¸ ì œê±° */
    function clearRoutePolylines() {
      routePolylines.forEach(polyline => polyline.setMap(null));
      routePolylines = [];
    }

    /**
     * ğŸš¨ Flutterì—ì„œ í˜¸ì¶œ: ì„¸ê·¸ë¨¼íŠ¸ ëª©ë¡ì„ ë°›ì•„ ê²½ë¡œë¥¼ ê·¸ë¦½ë‹ˆë‹¤.
     * isPassed ìƒíƒœì— ë”°ë¼ ìƒ‰ìƒì„ ë‹¤ë¥´ê²Œ ê·¸ë¦½ë‹ˆë‹¤.
     * ë‹¤ì–‘í•œ í•„ë“œ ì´ë¦„(startPoint/start/from ë“±)ì— ëŒ€ì‘
     */
    window.updateRouteSegments = function(segments) {
      if (!segments || !Array.isArray(segments) || segments.length === 0) {
        console.warn("JS: ì—…ë°ì´íŠ¸í•  ì„¸ê·¸ë¨¼íŠ¸ ë°ì´í„°ê°€ ì—†ê±°ë‚˜ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.", segments);
        return;
      }

      clearRoutePolylines();

      segments.forEach((segment, idx) => {
        // ğŸ” start / end í•„ë“œ ì—¬ëŸ¬ í˜•íƒœ ëŒ€ì‘
        const s = segment.startPoint || segment.start || segment.from;
        const e = segment.endPoint   || segment.end   || segment.to;

        if (!s || !e) {
          console.warn("ì„¸ê·¸ë¨¼íŠ¸ì— start/end ì •ë³´ ì—†ìŒ, index=", idx, segment);
          return;
        }

        const sLat = Number(s.lat ?? s.latitude);
        const sLng = Number(s.lng ?? s.longitude);
        const eLat = Number(e.lat ?? e.latitude);
        const eLng = Number(e.lng ?? e.longitude);

        if (Number.isNaN(sLat) || Number.isNaN(sLng) ||
            Number.isNaN(eLat) || Number.isNaN(eLng)) {
          console.warn("lat/lng íŒŒì‹± ì‹¤íŒ¨, index=", idx, { s, e });
          return;
        }

        const color = segment.isPassed ? '#555555' : '#8BC34A'; // íšŒìƒ‰ : ì—°ë‘ìƒ‰
        const weight = isNavigationMode ? 8 : 6;

        const linePath = [
          new kakao.maps.LatLng(sLat, sLng),
          new kakao.maps.LatLng(eLat, eLng)
        ];

        const polyline = new kakao.maps.Polyline({
          path: linePath,
          strokeWeight: weight,
          strokeColor: color,
          strokeOpacity: 0.96,
          strokeStyle: 'solid',
          zIndex: 3,
        });

        polyline.setMap(map);
        routePolylines.push(polyline);
      });

      console.log("âœ… updateRouteSegments ì™„ë£Œ, segments ê°œìˆ˜:", routePolylines.length);
    }

    /* ========= ì¶”ì²œ ê²½ë¡œ ê·¸ë¦¬ê¸° ========= */
    window.showRecommendedRoute = function(data) {
      // ğŸ”¹ segments í•„ë“œ ì—¬ëŸ¬ ì´ë¦„ ëŒ€ì‘
      let segments = null;
      if (Array.isArray(data.segments)) {
        segments = data.segments;
      } else if (Array.isArray(data.routeSegments)) {
        segments = data.routeSegments;
      } else if (Array.isArray(data.route_segments)) {
        segments = data.route_segments;
      }

      routeCoords = [];

      if (Array.isArray(data.polyline)) {
        // polyline: [{lat, lng}, ...] í˜•íƒœ
        routeCoords = data.polyline
          .filter(p => p && typeof p.lat === 'number' && typeof p.lng === 'number')
          .map(p => new kakao.maps.LatLng(p.lat, p.lng));
      } else if (segments && segments.length > 0) {
        // segments ê¸°ë°˜ìœ¼ë¡œ routeCoords ì¬êµ¬ì„±
        segments.forEach((seg, i) => {
          const s = seg.startPoint || seg.start || seg.from;
          const e = seg.endPoint   || seg.end   || seg.to;
          if (!s || !e) return;

          const sLat = Number(s.lat ?? s.latitude);
          const sLng = Number(s.lng ?? s.longitude);
          const eLat = Number(e.lat ?? e.latitude);
          const eLng = Number(e.lng ?? e.longitude);
          if (Number.isNaN(sLat) || Number.isNaN(sLng) ||
              Number.isNaN(eLat) || Number.isNaN(eLng)) {
            return;
          }

          if (i === 0) {
            routeCoords.push(new kakao.maps.LatLng(sLat, sLng));
          }
          routeCoords.push(new kakao.maps.LatLng(eLat, eLng));
        });
      } else {
        console.warn("âŒ showRecommendedRoute: polyline/segments ë‘˜ ë‹¤ ì—†ìŒ", data);
        return;
      }

      // â­ í„´ ì •ë³´ ì„¸íŒ…
      routeTurns = [];
      if (Array.isArray(data.turns)) {
        data.turns.forEach((t, idx) => {
          // 1) lat/lng ì§ì ‘ ë“¤ì–´ì˜¨ ê²½ìš°
          if (typeof t.lat === 'number' && typeof t.lng === 'number') {
            routeTurns.push({
              lat: t.lat,
              lng: t.lng,
              type: t.type || 'straight',
              atDistM: t.atDistM || null,
              instruction: t.instruction || "",
              id: t.id ?? idx.toString(),
            });
          }
          // 2) atDistMë§Œ ìˆê³  ì¢Œí‘œëŠ” ì—†ëŠ” ê²½ìš° â†’ polyline ìœ„ì—ì„œ ê³„ì‚°
          else if (typeof t.atDistM === 'number' && routeCoords.length > 1) {
            if (!kakao.maps.geometry || !kakao.maps.geometry.spherical) {
              return;
            }
            const target = t.atDistM;
            let acc = 0;
            for (let i = 0; i < routeCoords.length - 1; i++) {
              const segLen = kakao.maps.geometry.spherical.computeDistanceBetween(
                routeCoords[i],
                routeCoords[i + 1]
              );
              if (acc + segLen >= target) {
                const ratio = (target - acc) / segLen;
                const lat =
                  routeCoords[i].getLat() +
                  (routeCoords[i + 1].getLat() - routeCoords[i].getLat()) * ratio;
                const lng =
                  routeCoords[i].getLng() +
                  (routeCoords[i + 1].getLng() - routeCoords[i].getLng()) * ratio;
                routeTurns.push({
                  lat: lat,
                  lng: lng,
                  type: t.type || 'straight',
                  atDistM: t.atDistM,
                  instruction: t.instruction || "",
                  id: t.id ?? idx.toString(),
                });
                break;
              }
              acc += segLen;
            }
          }
        });
      }

      // ê¸°ì¡´ ê²ƒë“¤ ì •ë¦¬
      hideRunnerOnRoute();

      // â­ ì„¸ê·¸ë¨¼íŠ¸ ì›ë³¸ ì €ì¥ & ê¸°ë³¸ isPassed=false ë¡œ ì´ˆê¸°í™”
      if (segments && segments.length > 0) {
        routeSegmentsRaw = segments.map(seg => {
          const cloned = Object.assign({}, seg);
          cloned.isPassed = false;
          return cloned;
        });
        window.updateRouteSegments(routeSegmentsRaw);
      } else {
        // segmentsê°€ ì—†ìœ¼ë©´ ì „ì²´ ì´ˆë¡ìƒ‰ ë¼ì¸ í•˜ë‚˜
        const polyline = new kakao.maps.Polyline({
          path: routeCoords,
          strokeWeight: 6,
          strokeColor: '#00FF7F',
          strokeOpacity: 0.96,
          strokeStyle: 'solid',
          zIndex: 3,
        });
        polyline.setMap(map);
        routePolylines.push(polyline);
      }

      // ì¶œë°œ/ë„ì°© ë§ˆì»¤
      if (routeCoords.length > 0) {
        startMarker = new kakao.maps.Marker({
          map: map,
          position: routeCoords[0],
        });
        endMarker = new kakao.maps.Marker({
          map: map,
          position: routeCoords[routeCoords.length - 1],
        });

        const bounds = new kakao.maps.LatLngBounds();
        routeCoords.forEach(p => bounds.extend(p));
        map.setBounds(bounds);
      }

      window.r2uCourse = data;
      window.r2uTurns = routeTurns || [];
      window.r2uSpokenTurnIds = new Set();
      window.r2uLastIdx = 0;
      window.r2uIsOffRoute = false;
      window.r2uLastOffRouteSpoken = false;
    };

    /**
     * ğŸš¨ ê²½ë¡œ ìƒ‰ìƒ ì—…ë°ì´íŠ¸ + ì´íƒˆ/TTS ì²´í¬ ë‹´ë‹¹
     */
    window.updateRouteProgress = function(lat, lng) {
      if (!routeCoords.length) return;
      if (!kakao.maps.geometry || !kakao.maps.geometry.spherical) return;

      // 1. í„´ TTS ì²´í¬
      r2uCheckTurnTts(lat, lng);

      // 2. ê²½ë¡œ ì´íƒˆ ê°ì§€
      const cur = new kakao.maps.LatLng(lat, lng);
      let minDist = Infinity;
      for (let i = 0; i < routeCoords.length; i++) {
        const d = kakao.maps.geometry.spherical.computeDistanceBetween(cur, routeCoords[i]);
        if (d < minDist) {
          minDist = d;
        }
      }

      let isOffRoute = minDist > 15;
      window.r2uIsOffRoute = isOffRoute;

      if (isOffRoute) {
        if (!window.r2uLastOffRouteSpoken) {
          window.r2uLastOffRouteSpoken = true;
          const msg = "ê²½ë¡œì—ì„œ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤. ê²½ë¡œë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.";

          if (window.R2UTTS && window.R2UTTS.postMessage) {
            window.R2UTTS.postMessage(msg);
          } else if (typeof R2UTTS !== "undefined" && R2UTTS.postMessage) {
            R2UTTS.postMessage(msg);
          }
        }
      } else {
        window.r2uLastOffRouteSpoken = false;
      }

      // 3. â­ ì§€ë‚˜ì˜¨ êµ¬ê°„ íšŒìƒ‰ ì²˜ë¦¬ (segments ê¸°ë°˜)
      if (routeSegmentsRaw && routeSegmentsRaw.length && routeCoords.length > 1) {
        // í˜„ì¬ ìœ„ì¹˜ì™€ ê°€ì¥ ê°€ê¹Œìš´ routeCoords ì¸ë±ìŠ¤ ì°¾ê¸°
        let nearestIdx = 0;
        let min2 = Infinity;
        for (let i = 0; i < routeCoords.length; i++) {
          const d2 = kakao.maps.geometry.spherical.computeDistanceBetween(cur, routeCoords[i]);
          if (d2 < min2) {
            min2 = d2;
            nearestIdx = i;
          }
        }

        // routeCoords ëŠ” length = segments + 1 ê°€ì •
        const updatedSegments = [];
        for (let i = 0; i < routeSegmentsRaw.length; i++) {
          const seg = routeSegmentsRaw[i];
          const cloned = Object.assign({}, seg);
          // i ë²ˆì§¸ ì„¸ê·¸ë¨¼íŠ¸ëŠ” routeCoords[i] ~ routeCoords[i+1] êµ¬ê°„
          cloned.isPassed = i < nearestIdx;
          updatedSegments.push(cloned);
        }
        routeSegmentsRaw = updatedSegments;
        window.updateRouteSegments(routeSegmentsRaw);
      }
    }

    /* ========= ì§€ë„ ìë™ ë”°ë¼ê°€ê¸° ========= */
    window.followUser = function(lat, lng) {
      const pos = new kakao.maps.LatLng(lat, lng);
      map.panTo(pos);
    };

    /* ========= ëŸ¬ë„ˆ ì•„ì´ì½˜ ì—…ë°ì´íŠ¸ ========= */
    window.updateRunnerOnRoute = function(lat, lng, heading, onRoute) {
      if (!isNavigationMode) return;

      const pos = new kakao.maps.LatLng(lat, lng);

      const offRouteFlag = !(onRoute === true || onRoute === "true");
      const color = offRouteFlag ? "#E53935" : "#1E88E5";

      const h = Number(heading || 0);
      const offsetDeg = 0;

      if (!runnerOverlay) {
        runnerWrapperDiv = document.createElement("div");
        runnerWrapperDiv.className = "runner-wrapper";

        const html = `
          <div class="user-dir-marker-outer" id="runnerOuter">
            <div class="user-dir-marker-core" id="runnerCore" style="background:${color};"></div>
            <div class="user-dir-marker-arrow" style="border-bottom-color: ${color};"></div>
          </div>
        `;
        runnerWrapperDiv.innerHTML = html;

        runnerOverlay = new kakao.maps.CustomOverlay({
          position: pos,
          content: runnerWrapperDiv,
          zIndex: 5,
        });
        runnerOverlay.setMap(map);
      } else {
        runnerOverlay.setPosition(pos);
      }

      const outer = runnerWrapperDiv.querySelector("#runnerOuter");
      if (outer) {
        outer.style.transform = `rotate(${h + offsetDeg}deg)`;
      }

      const core = runnerWrapperDiv.querySelector("#runnerCore");
      if (core) {
        core.style.background = color;
      }
      const arrow = runnerWrapperDiv.querySelector(".user-dir-marker-arrow");
      if (arrow) {
        arrow.style.borderBottomColor = color;
      }
    };

    /* ========= ëŸ¬ë„ˆ/ê²½ë¡œ/í™”ì‚´í‘œ ì •ë¦¬ ========= */
    window.hideRunnerOnRoute = function() {
      if (runnerOverlay) {
        runnerOverlay.setMap(null);
        runnerOverlay = null;
      }
      runnerWrapperDiv = null;

      if (routeArrows.length) {
        routeArrows.forEach(a => a.setMap(null));
        routeArrows = [];
      }

      if (routeLineBase) {
        routeLineBase.setMap(null);
        routeLineBase = null;
      }

      clearRoutePolylines();

      if (startMarker) {
        startMarker.setMap(null);
        startMarker = null;
      }
      if (endMarker) {
        endMarker.setMap(null);
        endMarker = null;
      }

      routeCoords = [];
      routeTurns = [];
      routeSegmentsRaw = [];
      window.r2uSpokenTurnIds = new Set();
      window.r2uLastIdx = 0;
      window.r2uIsOffRoute = false;
      window.r2uLastOffRouteSpoken = false;
    };

    window.r2uCourse = window.r2uCourse || null;
    window.r2uTurns = window.r2uTurns || [];
    window.r2uSpokenTurnIds = window.r2uSpokenTurnIds || new Set();

    // ê°„ë‹¨ ê±°ë¦¬ ê³„ì‚° (ë¯¸í„° ë‹¨ìœ„)
    function r2uDistanceMeter(lat1, lng1, lat2, lng2) {
      const R = 6371000; // m
      const toRad = Math.PI / 180;
      const dLat = (lat2 - lat1) * toRad;
      const dLng = (lng2 - lng1) * toRad;
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * toRad) *
          Math.cos(lat2 * toRad) *
          Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // âœ… í„´ TTS ì²´í¬
    function r2uCheckTurnTts(currentLat, currentLng) {
      if (!isNavigationMode) return;
      if (!window.r2uTurns || window.r2uTurns.length === 0) return;

      const THRESHOLD = 40; // ëª‡ m ì•ì—ì„œ ì½ì„ì§€

      for (let i = 0; i < window.r2uTurns.length; i++) {
        const t = window.r2uTurns[i];

        const turnLat = t.lat ?? t.latitude ?? (t.point && t.point.lat);
        const turnLng = t.lng ?? t.longitude ?? (t.point && t.point.lng);
        if (turnLat == null || turnLng == null) continue;

        const turnId = t.id ?? i.toString();
        const dist = r2uDistanceMeter(currentLat, currentLng, turnLat, turnLng);

        console.log(`TTS Check: Turn ${i} (${t.type || 'straight'}) at ${dist.toFixed(1)}m. Spoken: ${window.r2uSpokenTurnIds.has(turnId)}`);

        if (dist < THRESHOLD && !window.r2uSpokenTurnIds.has(turnId)) {
          window.r2uSpokenTurnIds.add(turnId);

          const msg = t.instruction || "";
          if (!msg) continue;

          console.log(`[TTS SPEAK] ${msg}`);

          if (window.R2UTTS && window.R2UTTS.postMessage) {
            window.R2UTTS.postMessage(msg);
          }
          else if (typeof R2UTTS !== "undefined" && R2UTTS.postMessage) {
            R2UTTS.postMessage(msg);
          }
        }
      }
    }
  </script>
</body>
</html>
