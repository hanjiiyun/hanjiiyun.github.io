<!doctype html> 
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <title>R2U Kakao Map</title>

  <style>
    html, body {
      margin:0;
      padding:0;
      height:100%;
      overflow:hidden;
    }
    #map { width:100%; height:100vh; }

    /* ğŸ”µ ëŸ¬ë„ˆ ì•„ì´ì½˜ */
    .runner-wrapper {
      position: absolute;
      transform: translate(-50%, -50%);  /* ì¤‘ì‹¬ì´ ì¢Œí‘œì— ë”± ì˜¤ë„ë¡ */
      pointer-events: none; /* í´ë¦­/í„°ì¹˜ ì´ë²¤íŠ¸ëŠ” ì§€ë„ì— ì „ë‹¬ */
    }

    .user-dir-marker-outer {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      background: rgba(33, 150, 243, 0.28);
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      transition: transform 0.18s linear;
      will-change: transform;
    }

    .user-dir-marker-core {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #1E88E5;
      border: 3px solid #FFFF;
      box-shadow: 0 0 5px rgba(0,0,0,0.4);
      position: relative;
    }

    .user-dir-marker-arrow {
      position: absolute;
      top: -14px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 12px solid #1E88E5;
    }

    /* ì½”ìŠ¤ ìœ„ ë°©í–¥ í™”ì‚´í‘œ (ì¶œë°œ/í„´ ì§€ì ìš©) */
    .route-arrow {
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 16px solid #00FA73; /* ê¸°ë³¸: í˜•ê´‘ì´ˆë¡ */
      filter: drop-shadow(0 0 3px rgba(0,0,0,0.8));
    }
  </style>

  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=f3beaea643bdd2136019b366df1190cf&libraries=geometry"></script>
</head>

<body>
  <div id="map"></div>

  <script>
    /* ========= ì „ì—­ ========= */
    window.r2uOffRouteWarned = false;
    window.r2uBackToRouteWarned = false;

    window.r2uIsOffRoute = false;
    window.r2uLastOffRouteSpoken = false;
    window.r2uLastIdx = 0;

    let map;

    let routeCoords = [];      // ì „ì²´ polyline ì¢Œí‘œ
    let routePolylines = [];   // êµ¬ê°„ë³„ Polyline ì¸ìŠ¤í„´ìŠ¤
    let routeLineBase = null;  // í°ìƒ‰ ë‘êº¼ìš´ ë² ì´ìŠ¤ (ë„¤ë¹„ ëª¨ë“œìš©)
    let startMarker = null;
    let endMarker = null;

    let runnerOverlay = null;
    let runnerWrapperDiv = null;

    let isNavigationMode = false;
    let defaultMapLevel = 3;

    let routeArrows = [];      // í„´ í™”ì‚´í‘œ
    let routeTurns = [];       // í„´ ì •ë³´ ë°°ì—´

    /* ========= ì§€ë„ ì´ˆê¸°í™” ========= */
    function initMap() {
      const container = document.getElementById('map');
      map = new kakao.maps.Map(container, {
        center: new kakao.maps.LatLng(37.4507, 126.6530),
        level: 3
      });
      defaultMapLevel = map.getLevel();
    }
    initMap();

    /* ========= ë°©í–¥ í™”ì‚´í‘œ ========= */
    function createRouteArrows(coords) {
      if (!kakao.maps.geometry || !kakao.maps.geometry.spherical) {
        return;
      }

      if (routeArrows.length) {
        routeArrows.forEach(a => a.setMap(null));
        routeArrows = [];
      }
      if (!coords || coords.length < 2) return;

      if (routeTurns && routeTurns.length) {
        routeTurns.forEach(turn => {
          const tLat = turn.lat;
          const tLng = turn.lng;
          if (typeof tLat !== 'number' || typeof tLng !== 'number') return;

          const pos = new kakao.maps.LatLng(tLat, tLng);

          let nearestIdx = 0;
          let minDist = Infinity;
          for (let i = 0; i < coords.length; i++) {
            const d = kakao.maps.geometry.spherical.computeDistanceBetween(
              pos,
              coords[i]
            );
            if (d < minDist) {
              minDist = d;
              nearestIdx = i;
            }
          }

          const baseIdx = Math.min(nearestIdx, coords.length - 2);
          const segP1 = coords[baseIdx];
          const segP2 = coords[baseIdx + 1];

          const dx = segP2.getLng() - segP1.getLng();
          const dy = segP2.getLat() - segP1.getLat();
          const angleRad = Math.atan2(dy, dx);
          const angleDeg = angleRad * 180 / Math.PI;
          const rotateDeg = angleDeg - 90;

          let color = '#FFFFFF';
          if (turn.type === 'left') {
            color = '#FF7043';
          } else if (turn.type === 'right') {
            color = '#42A5F5';
          } else {
            color = '#FFFFFF';
          }

          const html =
            `<div class="route-arrow" style="
              transform: rotate(${rotateDeg}deg);
              transform-origin: 50% 50%;
              border-bottom-color: ${color};
            "></div>`;

          const overlay = new kakao.maps.CustomOverlay({
            position: pos,
            content: html,
            zIndex: 5
          });
          overlay.setMap(map);
          routeArrows.push(overlay);
        });
      }
    }

    /* ========= ë„¤ë¹„ê²Œì´ì…˜ ëª¨ë“œ on/off ========= */
    window.setNavigationMode = function(isNav) {
      isNavigationMode = !!isNav;

      if (isNavigationMode) {
        if (map && routeCoords.length > 0) {
          const startPos = routeCoords[0];
          map.setLevel(2);
          map.panTo(startPos);
        } else if (map) {
          map.setLevel(2);
        }

        if (routeCoords.length && !routeLineBase) {
          routeLineBase = new kakao.maps.Polyline({
            path: routeCoords,
            strokeWeight: 10,
            strokeColor: '#FFFFFF',
            strokeOpacity: 0.9,
            strokeStyle: 'solid',
            zIndex: 1,
          });
          routeLineBase.setMap(map);
        }

        createRouteArrows(routeCoords);
      } else {
        if (map) {
          map.setLevel(defaultMapLevel);
        }
        hideRunnerOnRoute();
      }
    };

    /** ê¸°ì¡´ ì„¸ê·¸ë¨¼íŠ¸ í´ë¦¬ë¼ì¸ë“¤ ì œê±° */
    function clearRoutePolylines() {
      routePolylines.forEach(polyline => polyline.setMap(null));
      routePolylines = [];
    }

    /**
     * âœ… routeCoords ê¸°ì¤€ìœ¼ë¡œ
     *    - index < currentIdx  : íšŒìƒ‰
     *    - index >= currentIdx : ì—°ë‘ìƒ‰
     * ë¡œ êµ¬ê°„ë³„ ë¼ì¸ì„ ë‹¤ì‹œ ê·¸ë¦½ë‹ˆë‹¤.
     */
    function drawRouteWithProgress(currentIdx) {
      if (!routeCoords || routeCoords.length < 2) return;

      clearRoutePolylines();

      for (let i = 0; i < routeCoords.length - 1; i++) {
        const from = routeCoords[i];
        const to   = routeCoords[i + 1];

        const isPassed = i < currentIdx;
        const color = isPassed ? '#555555' : '#8BC34A'; // íšŒìƒ‰ / ì—°ë‘ìƒ‰
        const weight = isNavigationMode ? 8 : 6;

        const linePath = [from, to];

        const polyline = new kakao.maps.Polyline({
          path: linePath,
          strokeWeight: weight,
          strokeColor: color,
          strokeOpacity: 0.96,
          strokeStyle: 'solid',
          zIndex: 3,
        });

        polyline.setMap(map);
        routePolylines.push(polyline);
      }
    }

    /* ========= ì¶”ì²œ ê²½ë¡œ ê·¸ë¦¬ê¸° ========= */
    window.showRecommendedRoute = function(data) {
      console.log("ğŸ“¦ showRecommendedRoute data:", data);

      routeCoords = [];

      // ğŸ”¹ 1) polyline ë°°ì—´ ìš°ì„  ì‚¬ìš© (ì˜ˆì „ì²˜ëŸ¼)
      if (Array.isArray(data.polyline)) {
        data.polyline.forEach(p => {
          if (!p) return;
          const lat = Number(p.lat ?? p.latitude);
          const lng = Number(p.lng ?? p.longitude);
          if (Number.isNaN(lat) || Number.isNaN(lng)) return;
          routeCoords.push(new kakao.maps.LatLng(lat, lng));
        });
      }

      // ğŸ”¹ 2) í˜¹ì‹œ polylineì´ ì—†ê³  segmentsë§Œ ìˆëŠ” ê²½ìš°: segmentsë¡œë¶€í„° coords ë³µì›
      if ((!routeCoords || routeCoords.length === 0) && Array.isArray(data.segments)) {
        data.segments.forEach((seg, i) => {
          const s = seg.startPoint || seg.start || seg.from || seg.start_point;
          const e = seg.endPoint   || seg.end   || seg.to   || seg.end_point;
          if (!s || !e) return;

          const sLat = Number(s.lat ?? s.latitude);
          const sLng = Number(s.lng ?? s.longitude);
          const eLat = Number(e.lat ?? e.latitude);
          const eLng = Number(e.lng ?? e.longitude);
          if (Number.isNaN(sLat) || Number.isNaN(sLng) ||
              Number.isNaN(eLat) || Number.isNaN(eLng)) return;

          if (i === 0) {
            routeCoords.push(new kakao.maps.LatLng(sLat, sLng));
          }
          routeCoords.push(new kakao.maps.LatLng(eLat, eLng));
        });
      }

      if (!routeCoords || routeCoords.length < 2) {
        console.warn("âŒ routeCoords ë¹„ì–´ìˆìŒ. polyline/segments ë‘˜ ë‹¤ íŒŒì‹± ì‹¤íŒ¨.", data);
        return;
      }

      // â­ í„´ ì •ë³´ ì„¸íŒ… (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
      routeTurns = [];
      if (Array.isArray(data.turns)) {
        data.turns.forEach((t, idx) => {
          if (typeof t.lat === 'number' && typeof t.lng === 'number') {
            routeTurns.push({
              lat: t.lat,
              lng: t.lng,
              type: t.type || 'straight',
              atDistM: t.atDistM || null,
              instruction: t.instruction || "",
              id: t.id ?? idx.toString(),
            });
          } else if (typeof t.atDistM === 'number' && routeCoords.length > 1) {
            if (!kakao.maps.geometry || !kakao.maps.geometry.spherical) {
              return;
            }
            const target = t.atDistM;
            let acc = 0;
            for (let i = 0; i < routeCoords.length - 1; i++) {
              const segLen = kakao.maps.geometry.spherical.computeDistanceBetween(
                routeCoords[i],
                routeCoords[i + 1]
              );
              if (acc + segLen >= target) {
                const ratio = (target - acc) / segLen;
                const lat =
                  routeCoords[i].getLat() +
                  (routeCoords[i + 1].getLat() - routeCoords[i].getLat()) * ratio;
                const lng =
                  routeCoords[i].getLng() +
                  (routeCoords[i + 1].getLng() - routeCoords[i].getLng()) * ratio;
                routeTurns.push({
                  lat: lat,
                  lng: lng,
                  type: t.type || 'straight',
                  atDistM: t.atDistM,
                  instruction: t.instruction || "",
                  id: t.id ?? idx.toString(),
                });
                break;
              }
              acc += segLen;
            }
          }
        });
      }

      // ê¸°ì¡´ ê²ƒë“¤ ì •ë¦¬
      hideRunnerOnRoute();

      // â­ ì²˜ìŒì—” ì „êµ¬ê°„ ì—°ë‘ìƒ‰ìœ¼ë¡œ ê·¸ë¦¬ê¸°
      drawRouteWithProgress(-1);

      // ì¶œë°œ/ë„ì°© ë§ˆì»¤
      if (routeCoords.length > 0) {
        startMarker = new kakao.maps.Marker({
          map: map,
          position: routeCoords[0],
        });
        endMarker = new kakao.maps.Marker({
          map: map,
          position: routeCoords[routeCoords.length - 1],
        });

        const bounds = new kakao.maps.LatLngBounds();
        routeCoords.forEach(p => bounds.extend(p));
        map.setBounds(bounds);
      }

      window.r2uCourse = data;
      window.r2uTurns = routeTurns || [];
      window.r2uSpokenTurnIds = new Set();
      window.r2uLastIdx = 0;
      window.r2uIsOffRoute = false;
      window.r2uLastOffRouteSpoken = false;
    };

    /**
     * ğŸš¨ ê²½ë¡œ ìƒ‰ìƒ ì—…ë°ì´íŠ¸ + ì´íƒˆ/TTS ì²´í¬ ë‹´ë‹¹
     */
    window.updateRouteProgress = function(lat, lng) {
      if (!routeCoords.length) return;
      if (!kakao.maps.geometry || !kakao.maps.geometry.spherical) return;

      // 1. í„´ TTS ì²´í¬
      r2uCheckTurnTts(lat, lng);

      // 2. ê²½ë¡œ ì´íƒˆ ê°ì§€
      const cur = new kakao.maps.LatLng(lat, lng);
      let minDist = Infinity;
      let nearestIdxForOffRoute = 0;

      for (let i = 0; i < routeCoords.length; i++) {
        const d = kakao.maps.geometry.spherical.computeDistanceBetween(cur, routeCoords[i]);
        if (d < minDist) {
          minDist = d;
          nearestIdxForOffRoute = i;
        }
      }

      let isOffRoute = minDist > 15;
      window.r2uIsOffRoute = isOffRoute;

      if (isOffRoute) {
        if (!window.r2uLastOffRouteSpoken) {
          window.r2uLastOffRouteSpoken = true;
          const msg = "ê²½ë¡œì—ì„œ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤. ê²½ë¡œë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.";

          if (window.R2UTTS && window.R2UTTS.postMessage) {
            window.R2UTTS.postMessage(msg);
          } else if (typeof R2UTTS !== "undefined" && R2UTTS.postMessage) {
            R2UTTS.postMessage(msg);
          }
        }
      } else {
        window.r2uLastOffRouteSpoken = false;
      }

      // 3. â­ ì§€ë‚˜ì˜¨ êµ¬ê°„ íšŒìƒ‰ ì²˜ë¦¬ (routeCoords ê¸°ì¤€)
      //    - nearestIdxForOffRouteë³´ë‹¤ ì•ìª½ ì¸ë±ìŠ¤ë¥¼ "ì§€ë‚˜ì˜¨ êµ¬ê°„"ìœ¼ë¡œ ë³¸ë‹¤.
      drawRouteWithProgress(nearestIdxForOffRoute);
    }

    /* ========= ì§€ë„ ìë™ ë”°ë¼ê°€ê¸° ========= */
    window.followUser = function(lat, lng) {
      const pos = new kakao.maps.LatLng(lat, lng);
      map.panTo(pos);
    };

    /* ========= ëŸ¬ë„ˆ ì•„ì´ì½˜ ì—…ë°ì´íŠ¸ ========= */
    window.updateRunnerOnRoute = function(lat, lng, heading, onRoute) {
      if (!isNavigationMode) return;

      const pos = new kakao.maps.LatLng(lat, lng);

      const offRouteFlag = !(onRoute === true || onRoute === "true");
      const color = offRouteFlag ? "#E53935" : "#1E88E5";

      const h = Number(heading || 0);
      const offsetDeg = 0;

      if (!runnerOverlay) {
        runnerWrapperDiv = document.createElement("div");
        runnerWrapperDiv.className = "runner-wrapper";

        const html = `
          <div class="user-dir-marker-outer" id="runnerOuter">
            <div class="user-dir-marker-core" id="runnerCore" style="background:${color};"></div>
            <div class="user-dir-marker-arrow" style="border-bottom-color: ${color};"></div>
          </div>
        `;
        runnerWrapperDiv.innerHTML = html;

        runnerOverlay = new kakao.maps.CustomOverlay({
          position: pos,
          content: runnerWrapperDiv,
          zIndex: 5,
        });
        runnerOverlay.setMap(map);
      } else {
        runnerOverlay.setPosition(pos);
      }

      const outer = runnerWrapperDiv.querySelector("#runnerOuter");
      if (outer) {
        outer.style.transform = `rotate(${h + offsetDeg}deg)`;
      }

      const core = runnerWrapperDiv.querySelector("#runnerCore");
      if (core) {
        core.style.background = color;
      }
      const arrow = runnerWrapperDiv.querySelector(".user-dir-marker-arrow");
      if (arrow) {
        arrow.style.borderBottomColor = color;
      }
    };

    /* ========= ëŸ¬ë„ˆ/ê²½ë¡œ/í™”ì‚´í‘œ ì •ë¦¬ ========= */
    window.hideRunnerOnRoute = function() {
      if (runnerOverlay) {
        runnerOverlay.setMap(null);
        runnerOverlay = null;
      }
      runnerWrapperDiv = null;

      if (routeArrows.length) {
        routeArrows.forEach(a => a.setMap(null));
        routeArrows = [];
      }

      if (routeLineBase) {
        routeLineBase.setMap(null);
        routeLineBase = null;
      }

      clearRoutePolylines();

      if (startMarker) {
        startMarker.setMap(null);
        startMarker = null;
      }
      if (endMarker) {
        endMarker.setMap(null);
        endMarker = null;
      }

      routeCoords = [];
      routeTurns = [];
      window.r2uSpokenTurnIds = new Set();
      window.r2uLastIdx = 0;
      window.r2uIsOffRoute = false;
      window.r2uLastOffRouteSpoken = false;
    };

    window.r2uCourse = window.r2uCourse || null;
    window.r2uTurns = window.r2uTurns || [];
    window.r2uSpokenTurnIds = window.r2uSpokenTurnIds || new Set();

    // ê°„ë‹¨ ê±°ë¦¬ ê³„ì‚° (ë¯¸í„° ë‹¨ìœ„)
    function r2uDistanceMeter(lat1, lng1, lat2, lng2) {
      const R = 6371000; // m
      const toRad = Math.PI / 180;
      const dLat = (lat2 - lat1) * toRad;
      const dLng = (lng2 - lng1) * toRad;
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * toRad) *
          Math.cos(lat2 * toRad) *
          Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // âœ… í„´ TTS ì²´í¬
    function r2uCheckTurnTts(currentLat, currentLng) {
      if (!isNavigationMode) return;
      if (!window.r2uTurns || window.r2uTurns.length === 0) return;

      const THRESHOLD = 40; // ëª‡ m ì•ì—ì„œ ì½ì„ì§€

      for (let i = 0; i < window.r2uTurns.length; i++) {
        const t = window.r2uTurns[i];

        const turnLat = t.lat ?? t.latitude ?? (t.point && t.point.lat);
        const turnLng = t.lng ?? t.longitude ?? (t.point && t.point.lng);
        if (turnLat == null || turnLng == null) continue;

        const turnId = t.id ?? i.toString();
        const dist = r2uDistanceMeter(currentLat, currentLng, turnLat, turnLng);

        console.log(`TTS Check: Turn ${i} (${t.type || 'straight'}) at ${dist.toFixed(1)}m. Spoken: ${window.r2uSpokenTurnIds.has(turnId)}`);

        if (dist < THRESHOLD && !window.r2uSpokenTurnIds.has(turnId)) {
          window.r2uSpokenTurnIds.add(turnId);

          const msg = t.instruction || "";
          if (!msg) continue;

          console.log(`[TTS SPEAK] ${msg}`);

          if (window.R2UTTS && window.R2UTTS.postMessage) {
            window.R2UTTS.postMessage(msg);
          }
          else if (typeof R2UTTS !== "undefined" && R2UTTS.postMessage) {
            R2UTTS.postMessage(msg);
          }
        }
      }
    }
  </script>
</body>
</html>
